import * as XLSX from 'xlsx'
import jsPDF from 'jspdf'
import html2canvas from 'html2canvas'

interface ExportData {
  projectName: string
  roomDimensions: {
    width: number
    length: number
    height: number
  }
  fixtures: Array<{
    brand: string
    model: string
    wattage: number
    ppf: number
    position: { x: number; y: number }
    enabled: boolean
  }>
  tiers?: any[]
  emergencyFixtures?: any[]
  analysisResult?: any
  metrics: {
    totalFixtures: number
    totalPower: number
    totalPPF: number
    avgPPFD: number
  }
}

export async function exportToPDF(data: ExportData, options?: {
  companyName?: string
  companyLogo?: string
  hideBranding?: boolean
  primaryColor?: { r: number; g: number; b: number }
}) {
  const pdf = new jsPDF('p', 'mm', 'a4')
  
  // Use custom branding or default to Vibelux
  const companyName = options?.companyName || 'Vibelux'
  const reportTitle = options?.hideBranding 
    ? 'Lighting Design Report' 
    : `${companyName} Lighting Design Report`
  const primaryColor = options?.primaryColor || { r: 79, g: 70, b: 229 } // Default purple
  
  // Title
  pdf.setFontSize(24)
  pdf.setTextColor(primaryColor.r, primaryColor.g, primaryColor.b)
  pdf.text(reportTitle, 20, 20)
  
  // Date
  pdf.setFontSize(10)
  pdf.setTextColor(100, 100, 100)
  pdf.text(`Generated: ${new Date().toLocaleDateString()}`, 20, 30)
  
  // Project Info
  pdf.setFontSize(16)
  pdf.setTextColor(0, 0, 0)
  pdf.text('Project Overview', 20, 45)
  
  pdf.setFontSize(12)
  pdf.text(`Room Dimensions: ${data.roomDimensions.width}m × ${data.roomDimensions.length}m × ${data.roomDimensions.height}m`, 20, 55)
  pdf.text(`Total Fixtures: ${data.metrics.totalFixtures}`, 20, 65)
  pdf.text(`Total Power: ${data.metrics.totalPower}W`, 20, 75)
  pdf.text(`Total PPF: ${data.metrics.totalPPF} μmol/s`, 20, 85)
  pdf.text(`Average PPFD: ${data.metrics.avgPPFD} μmol/m²/s`, 20, 95)
  
  // Fixture List
  pdf.setFontSize(16)
  pdf.text('Fixture Details', 20, 115)
  
  let yPos = 125
  pdf.setFontSize(10)
  data.fixtures.forEach((fixture, index) => {
    if (yPos > 270) {
      pdf.addPage()
      yPos = 20
    }
    pdf.text(
      `${index + 1}. ${fixture.brand} ${fixture.model} - ${fixture.wattage}W, ${fixture.ppf} PPF ${fixture.enabled ? '' : '(Disabled)'}`,
      20,
      yPos
    )
    yPos += 7
  })
  
  // Footer
  pdf.setFontSize(8)
  pdf.setTextColor(150, 150, 150)
  const footerText = options?.hideBranding 
    ? `Generated on ${new Date().toLocaleDateString()}`
    : `Generated by ${companyName} - Professional Horticultural Lighting Platform`
  pdf.text(footerText, 20, 285)
  
  // Save the PDF
  pdf.save(`vibelux-design-${Date.now()}.pdf`)
}

export async function exportToExcel(data: any[], filename: string, options?: {
  companyName?: string
  hideBranding?: boolean
}) {
  // Create a new workbook
  const wb = XLSX.utils.book_new()
  
  // Set workbook properties with branding
  wb.Props = {
    Title: options?.hideBranding ? 'Lighting Design Export' : `${options?.companyName || 'Vibelux'} Lighting Design`,
    Author: options?.companyName || 'Vibelux',
    CreatedDate: new Date()
  }
  
  // Convert data to worksheet
  const ws = XLSX.utils.json_to_sheet(data)
  
  // Add a header row with branding if not hidden
  if (!options?.hideBranding) {
    // Add company name at the top
    XLSX.utils.sheet_add_aoa(ws, [[`${options?.companyName || 'Vibelux'} Lighting Design Report`]], { origin: 'A1' })
    XLSX.utils.sheet_add_aoa(ws, [[`Generated: ${new Date().toLocaleDateString()}`]], { origin: 'A2' })
    
    // Shift data down by 3 rows
    const range = XLSX.utils.decode_range(ws['!ref'] || 'A1')
    for (let R = range.e.r; R >= 1; --R) {
      for (let C = range.s.c; C <= range.e.c; ++C) {
        const cellAddress = XLSX.utils.encode_cell({ r: R, c: C })
        const newAddress = XLSX.utils.encode_cell({ r: R + 3, c: C })
        if (ws[cellAddress]) {
          ws[newAddress] = ws[cellAddress]
          delete ws[cellAddress]
        }
      }
    }
    
    // Re-insert headers at row 4
    const headers = Object.keys(data[0] || {})
    headers.forEach((header, idx) => {
      const cellAddress = XLSX.utils.encode_cell({ r: 3, c: idx })
      ws[cellAddress] = { v: header, t: 's' }
    })
    
    // Update range
    range.e.r += 3
    ws['!ref'] = XLSX.utils.encode_range(range)
  }
  
  // Add worksheet to workbook
  XLSX.utils.book_append_sheet(wb, ws, 'Fixtures')
  
  // Generate Excel file and save
  XLSX.writeFile(wb, `${filename}.xlsx`)
}

export function exportToCSV(data: any[], filename: string) {
  const headers = Object.keys(data[0] || {})
  const csvContent = [
    headers.join(','),
    ...data.map(row => 
      headers.map(header => {
        const value = row[header]
        return typeof value === 'string' && value.includes(',') 
          ? `"${value}"` 
          : value
      }).join(',')
    )
  ].join('\n')
  
  const blob = new Blob([csvContent], { type: 'text/csv' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `${filename}.csv`
  a.click()
  URL.revokeObjectURL(url)
}

export function exportToJSON(data: any, filename: string) {
  const jsonContent = JSON.stringify(data, null, 2)
  const blob = new Blob([jsonContent], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = `${filename}.json`
  a.click()
  URL.revokeObjectURL(url)
}

export function exportToCAD(data: {
  roomDimensions: { width: number; length: number; height: number }
  fixtures: any[]
  plants: any[]
  benches: any[]
}) {
  // Create DXF content
  let dxfContent = '0\nSECTION\n2\nHEADER\n0\nENDSEC\n0\nSECTION\n2\nENTITIES\n';
  
  // Room boundary
  dxfContent += '0\nLWPOLYLINE\n8\nROOM\n90\n4\n70\n1\n'; // Closed polyline
  dxfContent += `10\n0\n20\n0\n`; // Point 1
  dxfContent += `10\n${data.roomDimensions.width}\n20\n0\n`; // Point 2
  dxfContent += `10\n${data.roomDimensions.width}\n20\n${data.roomDimensions.length}\n`; // Point 3
  dxfContent += `10\n0\n20\n${data.roomDimensions.length}\n`; // Point 4
  
  // Fixtures
  data.fixtures.forEach((f: any) => {
    // Draw fixture as rectangle
    dxfContent += '0\nLWPOLYLINE\n8\nFIXTURES\n90\n4\n70\n1\n';
    const halfWidth = f.width / 2;
    const halfLength = f.length / 2;
    dxfContent += `10\n${f.x - halfWidth}\n20\n${f.y - halfLength}\n`;
    dxfContent += `10\n${f.x + halfWidth}\n20\n${f.y - halfLength}\n`;
    dxfContent += `10\n${f.x + halfWidth}\n20\n${f.y + halfLength}\n`;
    dxfContent += `10\n${f.x - halfWidth}\n20\n${f.y + halfLength}\n`;
    
    // Add text label
    dxfContent += `0\nTEXT\n8\nLABELS\n10\n${f.x}\n20\n${f.y}\n40\n0.2\n1\n${f.model?.wattage || ''}W\n`;
  });
  
  // Plants
  data.plants.forEach((p: any) => {
    // Draw plant as circle
    dxfContent += `0\nCIRCLE\n8\nPLANTS\n10\n${p.x}\n20\n${p.y}\n40\n${p.width / 2}\n`;
  });
  
  // Benches
  data.benches.forEach((b: any) => {
    // Draw bench as rectangle
    dxfContent += '0\nLWPOLYLINE\n8\nBENCHES\n90\n4\n70\n1\n';
    const halfWidth = b.width / 2;
    const halfLength = b.length / 2;
    dxfContent += `10\n${b.x - halfWidth}\n20\n${b.y - halfLength}\n`;
    dxfContent += `10\n${b.x + halfWidth}\n20\n${b.y - halfLength}\n`;
    dxfContent += `10\n${b.x + halfWidth}\n20\n${b.y + halfLength}\n`;
    dxfContent += `10\n${b.x - halfWidth}\n20\n${b.y + halfLength}\n`;
  });
  
  dxfContent += '0\nENDSEC\n0\nEOF\n';
  
  // Create blob and download
  const blob = new Blob([dxfContent], { type: 'application/dxf' });
  const link = document.createElement('a');
  const url = URL.createObjectURL(blob);
  link.setAttribute('href', url);
  link.setAttribute('download', 'lighting-design.dxf');
  link.style.visibility = 'hidden';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}