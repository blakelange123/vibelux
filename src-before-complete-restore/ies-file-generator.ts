/**
 * Enhanced IES File Generator and Editor
 * Professional-grade IES photometric data file generation and manipulation
 */

export interface IESHeader {
  version: string;
  manufacturer: string;
  catalogNumber: string;
  description: string;
  lampDescription: string;
  ballastDescription: string;
  inputWatts: number;
  lumens: number;
  multiplier: number;
  numberOfVerticalAngles: number;
  numberOfHorizontalAngles: number;
  photometricType: number; // 1=Type C, 2=Type B, 3=Type A
  unitsType: number; // 1=feet, 2=meters
  width: number;
  length: number;
  height: number;
  ballastFactor: number;
  futureUse: number;
  inputWattsActual: number;
}

export interface IESPhotometricData {
  verticalAngles: number[];
  horizontalAngles: number[];
  candelaValues: number[][]; // [horizontal][vertical]
}

export interface IESFile {
  header: IESHeader;
  photometricData: IESPhotometricData;
  keywords: { [key: string]: string };
  tiltData?: {
    lamp: string;
    angles: number[];
    multiplyingFactors: number[];
  };
}

export interface PhotometricDistribution {
  angle: number;
  intensity: number;
  zone?: 'upper' | 'lower';
}

export interface LuminaireGeometry {
  width: number;
  length: number;
  height: number;
  shape: 'rectangular' | 'circular' | 'linear';
  mountingType: 'pendant' | 'surface' | 'recessed' | 'track';
}

export class IESFileGenerator {
  private defaultHeader: Partial<IESHeader> = {
    version: 'IESNA:LM-63-2002',
    manufacturer: 'VibeLux',
    photometricType: 1, // Type C
    unitsType: 2, // Meters
    ballastFactor: 1.0,
    futureUse: 1,
    multiplier: 1.0
  };

  /**
   * Generate IES file from fixture specifications
   */
  public generateIESFile(
    lumens: number,
    watts: number,
    beamAngle: number,
    fieldAngle: number,
    geometry: LuminaireGeometry,
    customDistribution?: PhotometricDistribution[]
  ): IESFile {
    const header: IESHeader = {
      ...this.defaultHeader,
      catalogNumber: this.generateCatalogNumber(lumens, watts, beamAngle),
      description: this.generateDescription(lumens, watts, beamAngle, geometry),
      lampDescription: `LED Array ${lumens} lumens`,
      ballastDescription: 'Integrated LED Driver',
      inputWatts: watts,
      lumens: lumens,
      width: geometry.width,
      length: geometry.length,
      height: geometry.height,
      inputWattsActual: watts,
      numberOfVerticalAngles: 37, // Standard 0-180째 in 5째 increments
      numberOfHorizontalAngles: 1  // Symmetric distribution
    } as IESHeader;

    const photometricData = customDistribution 
      ? this.generateCustomPhotometricData(customDistribution, lumens)
      : this.generateStandardPhotometricData(beamAngle, fieldAngle, lumens);

    const keywords = {
      'MANUFAC': header.manufacturer,
      'LUMCAT': header.catalogNumber,
      'LUMINAIRE': header.description,
      'LAMPCAT': header.lampDescription,
      'LAMP': `LED ${lumens}lm ${watts}W`,
      'BALLASTCAT': header.ballastDescription,
      'BALLAST': 'Integrated Driver',
      'MAINTCAT': 'LED L70@50000h',
      'OTHER': 'Generated by VibeLux Lighting Design Platform'
    };

    return {
      header,
      photometricData,
      keywords
    };
  }

  /**
   * Generate photometric data from beam/field angles
   */
  private generateStandardPhotometricData(
    beamAngle: number,
    fieldAngle: number,
    totalLumens: number
  ): IESPhotometricData {
    const verticalAngles: number[] = [];
    const horizontalAngles = [0]; // Symmetric distribution
    const candelaValues: number[][] = [[]];

    // Generate vertical angles from 0 to 180 degrees
    for (let angle = 0; angle <= 180; angle += 5) {
      verticalAngles.push(angle);
    }

    // Calculate intensity distribution using realistic LED profile
    const maxIntensity = (totalLumens * 0.318) / (Math.sin(beamAngle * Math.PI / 360) ** 2);
    
    for (let i = 0; i < verticalAngles.length; i++) {
      const angle = verticalAngles[i];
      let intensity = 0;

      if (angle <= 90) {
        // Upper hemisphere - main beam
        if (angle <= beamAngle / 2) {
          // Core beam area
          intensity = maxIntensity * Math.cos(angle * Math.PI / 180) ** 2;
        } else if (angle <= fieldAngle / 2) {
          // Transition zone
          const falloffFactor = (fieldAngle / 2 - angle) / (fieldAngle / 2 - beamAngle / 2);
          intensity = maxIntensity * 0.1 * Math.max(0, falloffFactor);
        } else if (angle <= 90) {
          // Spillover light
          intensity = maxIntensity * 0.01 * Math.cos(angle * Math.PI / 180) ** 4;
        }
      } else {
        // Lower hemisphere - minimal backlight
        const backAngle = 180 - angle;
        if (backAngle <= 30) {
          intensity = maxIntensity * 0.005 * Math.cos(backAngle * Math.PI / 180) ** 6;
        }
      }

      candelaValues[0].push(Math.max(0, intensity));
    }

    return {
      verticalAngles,
      horizontalAngles,
      candelaValues
    };
  }

  /**
   * Generate photometric data from custom distribution
   */
  private generateCustomPhotometricData(
    distribution: PhotometricDistribution[],
    totalLumens: number
  ): IESPhotometricData {
    const verticalAngles: number[] = [];
    const horizontalAngles = [0];
    const candelaValues: number[][] = [[]];

    // Create comprehensive angle array
    for (let angle = 0; angle <= 180; angle += 5) {
      verticalAngles.push(angle);
    }

    // Interpolate custom distribution to standard angles
    for (const targetAngle of verticalAngles) {
      const intensity = this.interpolateIntensity(distribution, targetAngle, totalLumens);
      candelaValues[0].push(intensity);
    }

    return {
      verticalAngles,
      horizontalAngles,
      candelaValues
    };
  }

  /**
   * Interpolate intensity at specific angle
   */
  private interpolateIntensity(
    distribution: PhotometricDistribution[],
    targetAngle: number,
    totalLumens: number
  ): number {
    // Sort distribution by angle
    const sorted = distribution.sort((a, b) => a.angle - b.angle);
    
    // Find surrounding points
    let lowerPoint = sorted[0];
    let upperPoint = sorted[sorted.length - 1];
    
    for (let i = 0; i < sorted.length - 1; i++) {
      if (sorted[i].angle <= targetAngle && sorted[i + 1].angle >= targetAngle) {
        lowerPoint = sorted[i];
        upperPoint = sorted[i + 1];
        break;
      }
    }
    
    // Linear interpolation
    if (lowerPoint.angle === upperPoint.angle) {
      return lowerPoint.intensity * totalLumens / 100;
    }
    
    const t = (targetAngle - lowerPoint.angle) / (upperPoint.angle - lowerPoint.angle);
    const interpolatedIntensity = lowerPoint.intensity + t * (upperPoint.intensity - lowerPoint.intensity);
    
    return interpolatedIntensity * totalLumens / 100;
  }

  /**
   * Generate catalog number
   */
  private generateCatalogNumber(lumens: number, watts: number, beamAngle: number): string {
    const efficacy = Math.round(lumens / watts);
    const beam = Math.round(beamAngle);
    return `VLX-${lumens}-${watts}W-${beam}B-${efficacy}E`;
  }

  /**
   * Generate description
   */
  private generateDescription(
    lumens: number,
    watts: number,
    beamAngle: number,
    geometry: LuminaireGeometry
  ): string {
    const efficacy = Math.round(lumens / watts);
    return `VibeLux ${lumens}lm ${watts}W LED ${geometry.shape} ${geometry.mountingType} ${beamAngle}째 beam ${efficacy}lm/W`;
  }

  /**
   * Export IES file as string
   */
  public exportIESString(iesFile: IESFile): string {
    let output = `${iesFile.header.version}\n`;
    
    // Add keywords
    for (const [key, value] of Object.entries(iesFile.keywords)) {
      output += `[${key}] ${value}\n`;
    }
    
    // Add tilt data if present
    if (iesFile.tiltData) {
      output += `TILT=${iesFile.tiltData.lamp}\n`;
      output += `${iesFile.tiltData.angles.length}\n`;
      output += `${iesFile.tiltData.angles.join(' ')}\n`;
      output += `${iesFile.tiltData.multiplyingFactors.join(' ')}\n`;
    } else {
      output += 'TILT=NONE\n';
    }
    
    // Add header data
    const header = iesFile.header;
    output += `${header.numberOfHorizontalAngles} ${header.numberOfVerticalAngles} ${header.photometricType} ${header.unitsType} ${header.width} ${header.length} ${header.height}\n`;
    output += `${header.ballastFactor} ${header.futureUse} ${header.inputWatts}\n`;
    output += `${header.lumens}\n`;
    output += `${header.multiplier}\n`;
    
    // Add angle data
    output += `${iesFile.photometricData.verticalAngles.join(' ')}\n`;
    output += `${iesFile.photometricData.horizontalAngles.join(' ')}\n`;
    
    // Add candela values
    for (let h = 0; h < iesFile.photometricData.horizontalAngles.length; h++) {
      const values = iesFile.photometricData.candelaValues[h];
      output += `${values.join(' ')}\n`;
    }
    
    return output;
  }

  /**
   * Parse existing IES file
   */
  public parseIESFile(iesString: string): IESFile {
    const lines = iesString.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    let lineIndex = 0;
    
    // Parse version
    const version = lines[lineIndex++];
    
    // Parse keywords
    const keywords: { [key: string]: string } = {};
    while (lineIndex < lines.length && lines[lineIndex].startsWith('[')) {
      const match = lines[lineIndex].match(/\[([^\]]+)\]\s*(.+)/);
      if (match) {
        keywords[match[1]] = match[2];
      }
      lineIndex++;
    }
    
    // Parse tilt data
    let tiltData: IESFile['tiltData'];
    if (lines[lineIndex].startsWith('TILT=') && !lines[lineIndex].includes('NONE')) {
      const tiltLamp = lines[lineIndex].split('=')[1];
      lineIndex++;
      const numTiltAngles = parseInt(lines[lineIndex++]);
      const tiltAngles = lines[lineIndex++].split(' ').map(Number);
      const tiltFactors = lines[lineIndex++].split(' ').map(Number);
      
      tiltData = {
        lamp: tiltLamp,
        angles: tiltAngles,
        multiplyingFactors: tiltFactors
      };
    } else {
      lineIndex++; // Skip TILT=NONE
    }
    
    // Parse header
    const headerLine1 = lines[lineIndex++].split(' ').map(Number);
    const headerLine2 = lines[lineIndex++].split(' ').map(Number);
    const lumens = parseFloat(lines[lineIndex++]);
    const multiplier = parseFloat(lines[lineIndex++]);
    
    const header: IESHeader = {
      version,
      manufacturer: keywords['MANUFAC'] || 'Unknown',
      catalogNumber: keywords['LUMCAT'] || 'Unknown',
      description: keywords['LUMINAIRE'] || 'Unknown',
      lampDescription: keywords['LAMPCAT'] || 'Unknown',
      ballastDescription: keywords['BALLASTCAT'] || 'Unknown',
      numberOfHorizontalAngles: headerLine1[0],
      numberOfVerticalAngles: headerLine1[1],
      photometricType: headerLine1[2],
      unitsType: headerLine1[3],
      width: headerLine1[4],
      length: headerLine1[5],
      height: headerLine1[6],
      ballastFactor: headerLine2[0],
      futureUse: headerLine2[1],
      inputWatts: headerLine2[2],
      lumens,
      multiplier,
      inputWattsActual: headerLine2[2]
    };
    
    // Parse angles and candela values
    const verticalAngles = lines[lineIndex++].split(' ').map(Number);
    const horizontalAngles = lines[lineIndex++].split(' ').map(Number);
    
    const candelaValues: number[][] = [];
    for (let h = 0; h < header.numberOfHorizontalAngles; h++) {
      candelaValues.push(lines[lineIndex++].split(' ').map(Number));
    }
    
    return {
      header,
      photometricData: {
        verticalAngles,
        horizontalAngles,
        candelaValues
      },
      keywords,
      tiltData
    };
  }

  /**
   * Validate IES file format
   */
  public validateIESFile(iesFile: IESFile): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Check header completeness
    if (!iesFile.header.version.includes('IESNA')) {
      errors.push('Invalid or missing IESNA version');
    }
    
    if (iesFile.header.lumens <= 0) {
      errors.push('Invalid lumen output');
    }
    
    if (iesFile.header.inputWatts <= 0) {
      errors.push('Invalid input wattage');
    }
    
    // Check photometric data consistency
    const expectedVerticalCount = iesFile.header.numberOfVerticalAngles;
    const actualVerticalCount = iesFile.photometricData.verticalAngles.length;
    
    if (expectedVerticalCount !== actualVerticalCount) {
      errors.push(`Vertical angle count mismatch: expected ${expectedVerticalCount}, got ${actualVerticalCount}`);
    }
    
    const expectedHorizontalCount = iesFile.header.numberOfHorizontalAngles;
    const actualHorizontalCount = iesFile.photometricData.horizontalAngles.length;
    
    if (expectedHorizontalCount !== actualHorizontalCount) {
      errors.push(`Horizontal angle count mismatch: expected ${expectedHorizontalCount}, got ${actualHorizontalCount}`);
    }
    
    // Check candela value matrix
    if (iesFile.photometricData.candelaValues.length !== expectedHorizontalCount) {
      errors.push('Candela value matrix horizontal dimension mismatch');
    }
    
    for (let h = 0; h < iesFile.photometricData.candelaValues.length; h++) {
      if (iesFile.photometricData.candelaValues[h].length !== expectedVerticalCount) {
        errors.push(`Candela value matrix vertical dimension mismatch at horizontal plane ${h}`);
      }
    }
    
    // Check for negative values
    for (const row of iesFile.photometricData.candelaValues) {
      for (const value of row) {
        if (value < 0) {
          errors.push('Negative candela values found');
          break;
        }
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }

  /**
   * Calculate photometric properties from IES data
   */
  public calculatePhotometricProperties(iesFile: IESFile): {
    efficacy: number;
    beamAngle: number;
    fieldAngle: number;
    maxIntensity: number;
    centerBeamIntensity: number;
    totalLumens: number;
    luminousIntensityDistribution: PhotometricDistribution[];
  } {
    const { header, photometricData } = iesFile;
    
    // Calculate efficacy
    const efficacy = header.lumens / header.inputWatts;
    
    // Find peak intensity and its angle
    let maxIntensity = 0;
    let maxIntensityAngle = 0;
    
    for (let v = 0; v < photometricData.verticalAngles.length; v++) {
      const intensity = photometricData.candelaValues[0][v]; // Assume symmetric
      if (intensity > maxIntensity) {
        maxIntensity = intensity;
        maxIntensityAngle = photometricData.verticalAngles[v];
      }
    }
    
    // Calculate beam and field angles
    const halfMaxIntensity = maxIntensity * 0.5;
    const tenPercentIntensity = maxIntensity * 0.1;
    
    let beamAngle = 0;
    let fieldAngle = 0;
    
    // Find angles where intensity drops to 50% and 10%
    for (let v = 0; v < photometricData.verticalAngles.length; v++) {
      const angle = photometricData.verticalAngles[v];
      const intensity = photometricData.candelaValues[0][v];
      
      if (intensity >= halfMaxIntensity && angle > maxIntensityAngle) {
        beamAngle = Math.max(beamAngle, (angle - maxIntensityAngle) * 2);
      }
      
      if (intensity >= tenPercentIntensity && angle > maxIntensityAngle) {
        fieldAngle = Math.max(fieldAngle, (angle - maxIntensityAngle) * 2);
      }
    }
    
    // Calculate center beam intensity
    const centerBeamIntensity = photometricData.candelaValues[0][0]; // First vertical angle (usually 0째)
    
    // Create luminous intensity distribution
    const luminousIntensityDistribution: PhotometricDistribution[] = [];
    for (let v = 0; v < photometricData.verticalAngles.length; v++) {
      luminousIntensityDistribution.push({
        angle: photometricData.verticalAngles[v],
        intensity: photometricData.candelaValues[0][v],
        zone: photometricData.verticalAngles[v] <= 90 ? 'upper' : 'lower'
      });
    }
    
    return {
      efficacy,
      beamAngle,
      fieldAngle,
      maxIntensity,
      centerBeamIntensity,
      totalLumens: header.lumens,
      luminousIntensityDistribution
    };
  }

  /**
   * Modify IES file properties
   */
  public modifyIESFile(
    iesFile: IESFile,
    modifications: {
      lumens?: number;
      watts?: number;
      beamAngleAdjustment?: number;
      intensityMultiplier?: number;
    }
  ): IESFile {
    const modified = JSON.parse(JSON.stringify(iesFile)) as IESFile;
    
    if (modifications.lumens !== undefined) {
      modified.header.lumens = modifications.lumens;
      modified.keywords['LAMP'] = `LED ${modifications.lumens}lm ${modified.header.inputWatts}W`;
    }
    
    if (modifications.watts !== undefined) {
      modified.header.inputWatts = modifications.watts;
      modified.header.inputWattsActual = modifications.watts;
      modified.keywords['LAMP'] = `LED ${modified.header.lumens}lm ${modifications.watts}W`;
    }
    
    if (modifications.intensityMultiplier !== undefined) {
      for (let h = 0; h < modified.photometricData.candelaValues.length; h++) {
        for (let v = 0; v < modified.photometricData.candelaValues[h].length; v++) {
          modified.photometricData.candelaValues[h][v] *= modifications.intensityMultiplier;
        }
      }
    }
    
    if (modifications.beamAngleAdjustment !== undefined) {
      // Apply beam angle adjustment by modifying the intensity distribution shape
      const adjustment = modifications.beamAngleAdjustment;
      for (let h = 0; h < modified.photometricData.candelaValues.length; h++) {
        for (let v = 0; v < modified.photometricData.candelaValues[h].length; v++) {
          const angle = modified.photometricData.verticalAngles[v];
          if (angle > 0) {
            // Apply cosine power adjustment to modify beam spread
            const powerFactor = adjustment > 0 ? 1 + adjustment / 50 : 1 / (1 - adjustment / 50);
            const cosineFactor = Math.cos(angle * Math.PI / 180) ** powerFactor;
            const originalCosine = Math.cos(angle * Math.PI / 180);
            
            if (originalCosine > 0) {
              modified.photometricData.candelaValues[h][v] *= cosineFactor / originalCosine;
            }
          }
        }
      }
    }
    
    return modified;
  }
}